rule   = rule,
f      = f,
ties   = ties,
z      = z,
NArule = NArule)
#### Extract
roi_df <- roi_sf %>% st_drop_geometry()
roi_df$date <- NULL
n_obs_df <- exact_extract(bm_r, roi_sf, count_n_obs, progress = !quiet) %>%
bind_cols(roi_df) %>%
tidyr::pivot_longer(cols = -c(names(roi_df)),
names_to = c(".value", "date"),
names_sep = "\\.t") %>%
dplyr::mutate(prop_non_na_pixels = .data$n_non_na_pixels / .data$n_pixels)
ntl_df <- exact_extract(bm_r, roi_sf, aggregation_fun, progress = !quiet) %>%
tidyr::pivot_longer(cols = everything(),
names_to = c(".value", "date"),
names_sep = "\\.t")
names(ntl_df)[names(ntl_df) != "date"] <-
paste0("ntl_", names(ntl_df)[names(ntl_df) != "date"])
ntl_df$date <- NULL
r <- bind_cols(n_obs_df, ntl_df)
# Apply through each date, extract, then append
} else{
# Download data --------------------------------------------------------------
r_list <- lapply(date, function(date_i){
# out <- tryCatch(
#    {
#### Make name for raster based on date
date_name_i <- define_date_name(date_i, product_id)
#### If save to file
if(output_location_type == "file"){
out_name_end <- paste0("_", date_name_i, ".Rds")
out_name <- paste0(out_name_begin, out_name_end)
out_path <- file.path(file_dir, out_name)
make_raster <- TRUE
if(file_skip_if_exists & file.exists(out_path)) make_raster <- FALSE
if(make_raster){
#### Make raster
r <- bm_raster_i(roi_sf = roi_sf,
product_id = product_id,
date = date_i,
bearer = bearer,
variable = variable,
quality_flag_rm = quality_flag_rm,
check_all_tiles_exist = check_all_tiles_exist,
h5_dir = h5_dir,
quiet = quiet,
temp_dir = temp_dir)
if(!is.null(r)){
names(r) <- date_name_i
#### Extract
r_agg <- exact_extract(x = r, y = roi_sf, fun = aggregation_fun,
progress = !quiet)
roi_df <- roi_sf
roi_df$geometry <- NULL
if(length(aggregation_fun) > 1){
names(r_agg) <- paste0("ntl_", names(r_agg))
r_agg <- bind_cols(r_agg, roi_df)
} else{
roi_df[[paste0("ntl_", aggregation_fun)]] <- r_agg
r_agg <- roi_df
}
if(add_n_pixels){
r_n_obs <- exact_extract(r, roi_sf, function(values, coverage_fraction)
sum(!is.na(values)),
progress = !quiet)
r_n_obs_poss <- exact_extract(r, roi_sf, function(values, coverage_fraction)
length(values),
progress = !quiet)
r_agg$n_pixels           <- r_n_obs_poss
r_agg$n_non_na_pixels    <- r_n_obs
r_agg$prop_non_na_pixels <- r_agg$n_non_na_pixels / r_agg$n_pixels
}
r_agg$date <- date_i
#### Export
saveRDS(r_agg, out_path)
} else{
warning(paste0('"', out_path, '" already exists; skipping.\n'))
}
}
r_out <- NULL # Saving as file, so output from function should be NULL
} else{
r_out <- bm_raster_i(roi_sf = roi_sf,
product_id = product_id,
date = date_i,
bearer = bearer,
variable = variable,
quality_flag_rm = quality_flag_rm,
check_all_tiles_exist = check_all_tiles_exist,
h5_dir = h5_dir,
quiet = quiet,
temp_dir = temp_dir)
names(r_out) <- date_name_i
if(add_n_pixels){
r_n_obs <- exact_extract(r_out, roi_sf, function(values, coverage_fraction)
sum(!is.na(values)),
progress = !quiet)
r_n_obs_poss <- exact_extract(r_out, roi_sf, function(values, coverage_fraction)
length(values),
progress = !quiet)
roi_sf$n_pixels           <- r_n_obs_poss
roi_sf$n_non_na_pixels    <- r_n_obs
roi_sf$prop_non_na_pixels <- roi_sf$n_non_na_pixels / roi_sf$n_pixels
}
r_out <- exact_extract(x = r_out, y = roi_sf, fun = aggregation_fun,
progress = !quiet)
roi_df <- roi_sf
roi_df$geometry <- NULL
if(length(aggregation_fun) > 1){
names(r_out) <- paste0("ntl_", names(r_out))
r_out <- bind_cols(r_out, roi_df)
} else{
roi_df[[paste0("ntl_", aggregation_fun)]] <- r_out
r_out <- roi_df
}
r_out$date <- date_i
}
return(r_out)
# TRY START
#
#  },
#  error=function(e) {
#    return(NULL)
#  }
# )
# TRY END
})
# Clean output ---------------------------------------------------------------
# Remove NULLs
r_list <- r_list[!sapply(r_list,is.null)]
r <- r_list %>%
bind_rows()
}
# Output dataframe when output_location_type = "file" ------------------------
if(output_location_type == "file"){
if(!file_return_null){
## Output path
date_names <- define_date_name(date, product_id)
out_name_end <- paste0("_",
date_names,
".Rds")
out_name <- paste0(out_name_begin, out_name_end)
## Restrict to files that exist, in case user enters date with no data
## (eg, year after current year)
all_files <- list.files(file_dir)
out_name <- out_name[out_name %in% all_files]
r <- file.path(file_dir, out_name) %>%
map_df(readRDS)
} else{
r <- NULL
}
}
unlink(temp_dir, recursive = T)
return(r)
}
#' Make Black Marble Raster
#'
#' Make a raster of nighttime lights from [NASA Black Marble data](https://blackmarble.gsfc.nasa.gov/)
#' @param roi_sf Region of interest; sf polygon. Must be in the [WGS 84 (epsg:4326)](https://epsg.io/4326) coordinate reference system.
#' @param product_id One of the following:
#' * `"VNP46A1"`: Daily (raw)
#' * `"VNP46A2"`: Daily (corrected)
#' * `"VNP46A3"`: Monthly
#' * `"VNP46A4"`: Annual
#' @param date Date of raster data. Entering one date will produce a `SpatRaster` object. Entering multiple dates will produce a `SpatRaster` object with multiple bands; one band per date.
#' * For `product_id`s `"VNP46A1"` and `"VNP46A2"`, a date (eg, `"2021-10-03"`).
#' * For `product_id` `"VNP46A3"`, a date or year-month (e.g., `"2021-10-01"`, where the day will be ignored, or `"2021-10"`).
#' * For `product_id` `"VNP46A4"`, year or date  (e.g., `"2021-10-01"`, where the month and day will be ignored, or `2021`).
#' @param bearer NASA bearer token. For instructions on how to create a token, see [here](https://github.com/worldbank/blackmarbler#bearer-token-).
#' @param variable Variable to used to create raster (default: `NULL`). If `NULL`, uses the following default variables:
#' * For `product_id` `:VNP46A1"`, uses `DNB_At_Sensor_Radiance_500m`.
#' * For `product_id` `"VNP46A2"`, uses `Gap_Filled_DNB_BRDF-Corrected_NTL`.
#' * For `product_id`s `"VNP46A3"` and `"VNP46A4"`, uses `NearNadir_Composite_Snow_Free`.
#' To see all variable choices, set `variable = ""` (this will create an error message that lists all valid variables). For additional information on variable choices, see [here](https://ladsweb.modaps.eosdis.nasa.gov/api/v2/content/archives/Document%20Archive/Science%20Data%20Product%20Documentation/VIIRS_Black_Marble_UG_v1.2_April_2021.pdf); for `VNP46A1`, see Table 3; for `VNP46A2` see Table 6; for `VNP46A3` and `VNP46A4`, see Table 9.
#' @param quality_flag_rm Quality flag values to use to set values to `NA`. Each pixel has a quality flag value, where low quality values can be removed. Values are set to `NA` for each value in the `quality_flag_rm` vector. Note that `quality_flag_rm` does not apply for `VNP46A1`. (Default: `NULL`).
#'
#'
#' For `VNP46A2` (daily data):
#' - `0`: High-quality, Persistent nighttime lights
#' - `1`: High-quality, Ephemeral nighttime Lights
#' - `2`: Poor-quality, Outlier, potential cloud contamination, or other issues
#'
#'
#' For `VNP46A3` and `VNP46A4` (monthly and annual data):
#' - `0`: Good-quality, The number of observations used for the composite is larger than 3
#' - `1`: Poor-quality, The number of observations used for the composite is less than or equal to 3
#' - `2`: Gap filled NTL based on historical data
#' @param check_all_tiles_exist Check whether all Black Marble nighttime light tiles exist for the region of interest. Sometimes not all tiles are available, so the full region of interest may not be covered. If `TRUE`, skips cases where not all tiles are available. (Default: `TRUE`).
#' @param interpol_na When data for more than one date is downloaded, whether to interpolate `NA` values using the `terra::approximate` function. Additional arguments for the `terra::approximate` function can also be passed into `bm_raster` (eg, `method`, `rule`, `f`, `ties`, `z`, `NA_rule`). (Default: `FALSE`).
#' @param output_location_type Where to produce output; either `memory` or `file`. If `memory`, functions returns a raster in R. If `file`, function exports a `.tif` file and returns `NULL`.
#' For `output_location_type = file`:
#' @param file_dir The directory where data should be exported (default: `NULL`, so the working directory will be used)
#' @param file_prefix Prefix to add to the file to be saved. The file will be saved as the following: `[file_prefix][product_id]_t[date].tif`
#' @param file_skip_if_exists Whether the function should first check wither the file already exists, and to skip downloading or extracting data if the data for that date if the file already exists (default: `TRUE`).
#' @param file_return_null Whether to return `NULL` instead of a `SpatRaster`. When `output_location_type = 'file'`, the function will export data to the `file_dir` directory. When `file_return_null = FALSE`, the function will also return a `SpatRaster` of the queried data---so the data is available in R memory. Setting `file_return_null = TRUE`, data will be saved to `file_dir` but no data will be returned by the function to R memory (default: `FALSE`).
#' @param h5_dir Black Marble data are originally downloaded as `h5` files. If `h5_dir = NULL`, the function downloads to a temporary directory then deletes the directory. If `h5_dir` is set to a path, `h5` files are saved to that directory and not deleted. The function will then check if the needed `h5` file already exists in the directory; if it exists, the function will not re-download the `h5` file.
#' @param quiet Suppress output that show downloading progress and other messages. (Default: `FALSE`).
#' @param ... Additional arguments for `terra::approximate`, if `interpol_na = TRUE`
#'
#' @return Raster
#'
#' @author Robert Marty <rmarty@@worldbank.org>
#' @examples
#' \dontrun{
#' # Define bearer token
#' bearer <- "BEARER-TOKEN-HERE"
#'
#' # sf polygon of Ghana
#' library(geodata)
#' roi_sf <- gadm(country = "GHA", level=0, path = tempdir()) %>% st_as_sf()
#'
#' # Daily data: raster for October 3, 2021
#' ken_20210205_r <- bm_raster(roi_sf = roi_sf,
#'                             product_id = "VNP46A2",
#'                             date = "2021-10-03",
#'                             bearer = bearer)
#'
#' # Monthly data: raster for March 2021
#' ken_202103_r <- bm_raster(roi_sf = roi_sf,
#'                           product_id = "VNP46A3",
#'                           date = "2021-03-01",
#'                           bearer = bearer)
#'
#' # Annual data: raster for 2021
#' ken_2021_r <- bm_raster(roi_sf = roi_sf,
#'                         product_id = "VNP46A4",
#'                         date = 2021,
#'                         bearer = bearer)
#'}
#'
#' @export
#'
#' @import readr
#' @import dplyr
#' @import sf
#' @import exactextractr
#' @import stringr
#' @import httr2
#' @import lubridate
#' @rawNamespace import(tidyr, except = c(extract))
#' @rawNamespace import(purrr, except = c(flatten_df, values))
#' @rawNamespace import(terra, except = c(intersect, values, origin, union))
#'
# @rawNamespace import(utils, except = c(stack, unstack))
bm_raster <- function(roi_sf,
product_id,
date,
bearer,
variable = NULL,
quality_flag_rm = NULL,
check_all_tiles_exist = TRUE,
interpol_na = FALSE,
output_location_type = "memory", # memory, file
file_dir = NULL,
file_prefix = NULL,
file_skip_if_exists = TRUE,
file_return_null = FALSE,
h5_dir = NULL,
quiet = FALSE,
...){
# Errors & Warnings ----------------------------------------------------------
if( (interpol_na == T) & (length(date) == 1) ){
stop("If interpol_na = TRUE, then must have more than one date")
}
if( (interpol_na == T) & (output_location_type == "file") ){
interpol_na <- F
stop("interpol_na ignored. Interpolation only occurs when output_location_type = 'memory'")
}
if(class(roi_sf)[1] == "SpatVector") roi_sf <- roi_sf %>% st_as_sf()
if(!("sf" %in% class(roi_sf))){
stop("roi must be an sf object")
}
# Required parameters used in try statement, so error not generated when used,
# so use them here
roi_sf     <- roi_sf
product_id <- product_id
date       <- date
bearer     <- bearer
# Assign interpolation variables ---------------------------------------------
if(interpol_na == T){
if(!exists("method")) method <- "linear"
if(!exists("rule"))   rule   <- 1
if(!exists("f"))      f      <- 0
if(!exists("ties"))   ties   <- mean
if(!exists("z"))      z      <- NULL
if(!exists("NArule")) NArule <- 1
}
# Define Tempdir -------------------------------------------------------------
temp_main_dir = tempdir()
current_time_millis = as.character(as.numeric(Sys.time())*1000) %>%
str_replace_all("[:punct:]", "")
temp_dir = file.path(temp_main_dir, paste0("bm_raster_temp_", current_time_millis))
dir.create(temp_dir, showWarnings = F)
# NTL Variable ---------------------------------------------------------------
variable <- define_variable(variable, product_id)
# Filename root --------------------------------------------------------------
# Define outside of lapply, as use this later to aggregate rasters
if(output_location_type == "file"){
out_name_begin <- paste0(file_prefix,
product_id, "_",
variable, "_",
"qflag",
quality_flag_rm %>% paste0(collapse="_"))
}
# Download data --------------------------------------------------------------
r_list <- lapply(date, function(date_i){
#out <- tryCatch(
#  {
#### Make name for raster based on date
date_name_i <- define_date_name(date_i, product_id)
#### If save as tif format
if(output_location_type == "file"){
## Output path
out_name_end <- paste0("_",
date_name_i,
".tif")
out_name <- paste0(out_name_begin, out_name_end)
out_path <- file.path(file_dir, out_name)
make_raster <- TRUE
if(file_skip_if_exists & file.exists(out_path)) make_raster <- FALSE
if(make_raster){
r <- bm_raster_i(roi_sf = roi_sf,
product_id = product_id,
date = date_i,
bearer = bearer,
variable = variable,
quality_flag_rm = quality_flag_rm,
check_all_tiles_exist = check_all_tiles_exist,
h5_dir = h5_dir,
quiet = quiet,
temp_dir = temp_dir)
if(!is.null(r)){
names(r) <- date_name_i
terra::writeRaster(r, out_path)
}
} else{
message(paste0('"', out_path, '" already exists; skipping.\n'))
}
r_out <- NULL # Saving as tif file, so output from function should be NULL
} else{
r_out <- bm_raster_i(roi_sf = roi_sf,
product_id = product_id,
date = date_i,
bearer = bearer,
variable = variable,
quality_flag_rm = quality_flag_rm,
check_all_tiles_exist = check_all_tiles_exist,
h5_dir = h5_dir,
quiet = quiet,
temp_dir = temp_dir)
if(!is.null(r_out)){
names(r_out) <- date_name_i
}
}
return(r_out)
})
# Clean output ---------------------------------------------------------------
# Remove NULLs
r_list <- r_list[!sapply(r_list,is.null)]
if(length(r_list) == 1){
r <- r_list[[1]]
} else if (length(r_list) > 1){
r <- terra::rast(r_list)
} else{
r <- NULL
}
# Interpolate ----------------------------------------------------------------
if(interpol_na %in% T){
r <- terra::approximate(r,
method = method,
rule   = rule,
f      = f,
ties   = ties,
z      = z,
NArule = NArule)
}
unlink(temp_dir, recursive = T)
# Output raster when output_location_type = "file" ---------------------------
if(output_location_type == "file"){
if(!file_return_null){
## Output path
date_names <- define_date_name(date, product_id)
out_name_end <- paste0("_",
date_names,
".tif")
out_name <- paste0(out_name_begin, out_name_end)
## Restrict to files that exist, in case user enters date with no data
## (eg, year after current year)
all_files <- list.files(file_dir)
out_name <- out_name[out_name %in% all_files]
if(length(out_name) > 0){
r <- file.path(file_dir, out_name) %>%
rast()
} else{
r <- NULL
}
} else{
r <- NULL
}
}
return(r)
}
bm_raster_i <- function(roi_sf,
product_id,
date,
bearer,
variable,
quality_flag_rm,
check_all_tiles_exist,
h5_dir,
quiet,
temp_dir){
# Black marble grid ----------------------------------------------------------
bm_tiles_sf <- read_sf("https://raw.githubusercontent.com/worldbank/blackmarbler/main/data/blackmarbletiles.geojson")
# Prep dates -----------------------------------------------------------------
## For monthly, allow both yyyy-mm and yyyy-mm-dd (where -dd is ignored)
if(product_id == "VNP46A3"){
if(nchar(date) %in% 7){
date <- paste0(date, "-01")
}
}
## For year, allow both yyyy and yyyy-mm-dd (where -mm-dd is ignored)
if(product_id == "VNP46A4"){
if(nchar(date) %in% 4){
date <- paste0(date, "-01-01")
}
}
# Grab tile dataframe --------------------------------------------------------
year  <- date %>% year()
month <- date %>% month()
day   <- date %>% yday()
bm_files_df <- create_dataset_name_df(product_id = product_id,
all = T,
years = year,
months = month,
days = day)
# Only move forward if dataset exists ---
if(nrow(bm_files_df) == 0){
warning(paste0("No satellite imagery exists for ", date, "; skipping"))
r <- NULL
} else{
# Intersecting tiles ---------------------------------------------------------
# Remove grid along edges, which causes st_intersects to fail
bm_tiles_sf <- bm_tiles_sf[!(bm_tiles_sf$TileID %>% str_detect("h00")),]
bm_tiles_sf <- bm_tiles_sf[!(bm_tiles_sf$TileID %>% str_detect("v00")),]
inter <- tryCatch(
{
inter <- st_intersects(bm_tiles_sf, roi_sf, sparse = F) %>%
apply(1, sum)
inter
},
error = function(e){
warning("Issue with `roi_sf` intersecting with blackmarble tiles; try buffering by a width of 0: eg, st_buffer(roi_sf, 0)")
stop("Issue with `roi_sf` intersecting with blackmarble tiles; try buffering by a width of 0: eg, st_buffer(roi_sf, 0)")
}
)
grid_use_sf <- bm_tiles_sf[inter > 0,]
# Make Raster ----------------------------------------------------------------
tile_ids_rx <- grid_use_sf$TileID %>% paste(collapse = "|")
bm_files_df <- bm_files_df[bm_files_df$name %>% str_detect(tile_ids_rx),]
if(nrow(bm_files_df) == 0){
warning(paste0("No satellite imagery exists for ", date, "; skipping"))
r <- NULL
} else{
if( (nrow(bm_files_df) < nrow(grid_use_sf)) & check_all_tiles_exist){
warning("Not all satellite imagery tiles for this location exist, so skipping. To ignore this error and process anyway, set check_all_tiles_exist = FALSE")
#stop("Not all satellite imagery tiles for this location exist, so skipping. To ignore this error and process anyway, set check_all_tiles_exist = FALSE")
}
unlink(file.path(temp_dir, product_id), recursive = T)
if(quiet == F){
message(paste0("Processing ", nrow(bm_files_df), " nighttime light tiles"))
}
r_list <- lapply(bm_files_df$name, function(name_i){
download_raster(name_i, temp_dir, variable, bearer, quality_flag_rm, h5_dir, quiet)
})
if(length(r_list) == 1){
r <- r_list[[1]]
} else{
r <- do.call(terra::mosaic, c(r_list, fun = "max"))
}
## Crop
r <- r %>% terra::crop(roi_sf)
unlink(file.path(temp_dir, product_id), recursive = T)
}
}
return(r)
}
r <- bm_raster(roi_sf = roi_sf,
product_id = "VNP46A4",
date = 2023,
bearer = nasa_bearer,
file_dir = file.path(ntl_bm_dir, "rasters", "annual"))
roi_sf <- load_gadm(0)
r <- bm_raster(roi_sf = roi_sf,
product_id = "VNP46A4",
date = 2023,
bearer = nasa_bearer,
file_dir = file.path(ntl_bm_dir, "rasters", "annual"))
r
plot(r)
r <- bm_raster(roi_sf = roi_sf,
product_id = "VNP46A4",
date = 2024,
bearer = nasa_bearer,
file_dir = file.path(ntl_bm_dir, "rasters", "annual"))
ntl_df <- readRDS(file.path(ntl_bm_dir, "aggregated",
paste0("ntl_", "adm0", "_", "annual", ".Rds")))
ntl_df$date
ntl_df <- readRDS(file.path(ntl_bm_dir, "aggregated",
paste0("ntl_", "adm0", "_", "monthly", ".Rds")))
ntl_df$date
